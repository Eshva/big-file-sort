# Вступление для работодателей и HR-агентов
Когда руководитель ищет нового разработчика в свою команду, ему хочется заранее узнать о кандидате довольно много разнообразных вещей, чтобы сделать правильный выбор и просто понять, справится ли кандидат с работой. Работодателя интересует: впишется ли кандидат в команду, справится ли с освоением предметной области, будет ли он соответствовать занимаемой позиции (не будет ли ему слишком сложно или наоборот слишком просто/скучно) и т.д. Я знаю это не понаслышке, так как сам многократно искал сотрудников в свои команды и участвовал в собеседовании кандидатов в другие команды.

Среди прочего работодатель хочет проверить навыки кодирования кандидата (да, как ни странно, бывают дипломированные программисты, неспособные писать код). Нет ничего лучше для такой проверки, чем дать задание на написание кода. Вот только кандидаты редко соглашаются выполнять такие задания. Причина проста: когда программист находится в активном поиске, у него нет времени на подобные задания, которые (чтобы там не думали работодатели, а тем более HR-агентов) занимают не час, а до нескольких дней, если кандидат хочет показать свои профессиональные навыки. Когда у программиста следующие неделя-две расписаны по 2-3 собеседования в день, у нет времени на что-то подобное.

Понимая потребности и ограничения обеих сторон, я, для демонстрации своих навыков, решил создать данный репозиторий, в котором реализовал одно из возможных заданий на кодирование. Потенциальные работодатели на его основе смогут оценить мои навыки профессионального программирования, а мне не придётся отказываться от написания тестовых заданий. Поскольку я рассматриваю лишь позиции уровня senior, в данном тестовом проекте я решил показать не только само кодирование, но и другие необходимые, с моей точки зрения, навыки:

* использование TDD (не просто модульные тесты, а именно разработка через тестирование),
* анализ производительности и потребления памяти (JetBrains dotMemory и dotTrace, BenchmarkDotNet),
* оптимизация кода с точки зрения производительности и потребляемой памяти,
* формулирование задания (начальный вариант был менее конкретен),
* описание проделанной работы,
* и некоторые другие.

К сожалению, ввиду относительной простоты проекта не удалось показать навыки, связанные с архитектурой и дизайном, разработкой асинхронного кода, развёртыванием кода в кластере k8s, end-to-end тестированием приложений, управлением версиями кода и много другого. С другой стороны, написано и показано достаточно, чтобы не приставать ко мне с запросами на написание ещё чего-то для проверки моих навыков программирования.

# Тестовое задание: Сортировка большого текстового файла

Необходимо написать две утилиты командной строки, к которым предъявляются следующие требования.

## Программа генератор большого файла
* Программа принимает в качестве аргументов командной строки имя файла и количество генерируемых линий.
* Формат каждой линии: `<Число>. <Строка>`.
* Число генерируется случайным образом в диапазоне [0..10000].
* Строка генерируется случайным образом. Длинна строки выбирается случайным образом в диапазоне [20..100] символов.
* Строка должна содержать случайные символы из следующего набора: `a..zA..Z `.
* Можно использовать сторонние библиотеки.
* Часть строк должна повторяться.

## Программа сортировки большого файла
* Программа принимает в качестве аргументов командной строки имя файла, который нужно отсортировать.
* Сортировка производится in-place: исходный файл и отсортированный являются одним файлом.
* Линии сортируются вначале по элементу `Строка`, затем по элементу `Число`.
* Файл для сортировки может быть размером до 200GB.
* Память ограничена.
* Можно использовать сторонние библиотеки, кроме реализации самой сортировки.

## Дополнительные требования
* Выполнить сравнение нескольких вариантов реализации по потребляемой памяти и времени выполнения. Это могут быть варианты последовательного улучшаемые варианты.
* Написать модульные и end-to-end тесты.
* Реализовать документацию для пользователя утилит.

# Этапы реализации

## Этап №1. Наивная реализация

Первая реализация сделана умышленно наивной, чтобы показать выявление проблем с помощью инструментов оценки производительности и потребления памяти, и их последующее устранение с помощью целевых рефакторингов. В частности, для реализации специфической сортировки линий файлов (вначале по строке, затем по номеру строки, стоящему раньше строки), реализован класс `NumberedLine`. Данный класс как раз реализует сравнение объектов данного класса. Проблема данного класса состоит в том, что он из линии файла, переданной в конструкторе, выделяет две подстроки: одну для парсинга числа, вторую для строковой части. Разумеется, это приводит к большому трафику памяти на объектах типов `String` и `NumberedLine`, что видно по характерной "пиле" на графике в JetBrains dotMemory. При анализе back traces видно, что 50% всего трафика памяти приходится на метод `System.String.Substring(Int32, Int32)` в `BigFile.Sorter.NumberedLine.Parse(String)`. Более того, многие объекты этих типов переживают 0-ое поколение и попадают в 1-ое.

Задачей следующего этапа будет избавиться от типа `NumberedLine` и связанного с ним трафика памяти. Остальные проблемы будут показаны по мере движения по этапам реализации.

## Этап №2. Отказ от лишнего выделения строк

В ходе данного этапа я отказался от использования класса `NumberedLine` для сравнения строк в пользу класса-сравнивателя `NumberedLineComparer`, реализующего стандартный интерфейс `IComparer<string>`. `NumberedLineComparer` в своей работе использует перегрузки методов сравнения и парсинга, использующих `ReadOnlySpan<string>`. Это позволило уменьшить количество выделяемой памяти в 3 раза и, соответственно, уменьшило трафик памяти, однако производительность ниже первого варианта.

По-прежнему в куче выделяется большое количество строк. Это связано с использованием `StreamReader.ReadLine`.

## Этап №3. Использование вместо чтения отдельных линий чтения в буфер

На предыдущем этапе удалось отказаться от лишнего выделения строк при их парсинге, но содержимое файлов по-прежнему читалось и записывалось отдельными линиями. Я решил совсем отказаться от работы со строками в пользу чтения содержимого файлов в буферы на обоих этапах сортировки: первоначальной подготовке отсортированных частей и последующего слияния этих частей с сортировкой. Запись в файлы также происходит из буферов. Куски памяти выделяются по средствам `MemoryPool`, что обеспечивает их повторное использование.

При создании отсортированных частей кусок входного файла загружается в буфер, в нём ищутся линии файла, которые затем сортируются по средствам класса `BufferBubbleSorter`. Результатом работы данного сортировщика является не отсортированный список линий, а отсортированный список ссылок на линии в буфере в виде spans. Затем этот список используется для записи в файл отсортированной части.

Слияние отсортированных частей написано немного "хитрее". Поскольку отсортированные части нет нужды читать в память целиком, я принял решение написать итератор этих файлов, который также использует чтение в буфер с последующим последовательным поиском линий текстового файла. Поскольку в общем случае размер файла может быть больше размера буфера, пришлось отслеживать начало разорванной строки. Осложняет это дело также то, что окончание линии может состоять из различных сочетаний символов CR и LF. Для написания столь сложного кода изрядно помогло TDD.

Результатом данного усовершенствования стало значительно меньшее потребление памяти (в 40 раз) и почти двухкратное ускорение в сравнении с первым наивным вариантом.

## Этап №4. Оптимизация создания отсортированных частей

Чтобы ускорить приложение, заменил сортировку пузырьком на сортировку пирамидой (heap sort). Это позволило ускорить приложение. Данный вариант уже в три раза быстрее исходного. Потребление памяти относительно предыдущего не изменилось.

Хотел реализовать компиляцию в один исполняемый файл с попутным tree shaking, но из-за benchmark-сборки этого сделать не удалось. Поэтому оставил как есть.

Ещё больше можно ускорить приложение можно за счёт многопоточной сортировки подготавливаемых частей, но решил не усложнять код и тратить время.
